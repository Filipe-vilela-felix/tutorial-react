		REACT

aula_3: Folder Structure

É composto por três pastas e quatro arquivos.

Os arquivos são: 
	package.json -> além de mostrar qual versão estou utilizando, também possui "scripts", que por sua vez, garante a execução do aplicativo;
	package-lock.jason -> garante uma instalação consistente de suas dependencias;
	Obs: os arquivos README.md e .gitignore não foram mencionados com importancia;

As pastas são:
	node_modules -> esta é a pasta na qual todas as dependencias são instaladas;
	public -> dentro dela se encontram três arquivos:
		1º manifest.json -> se preocupa com aplicativos da web fora do nosso escopo;
		2º faviction.ico -> onde se encontra a guia do navegador (nada específico);
		3º index.html -> não será adcionado nenhum código nesse arquico, no máximo algumas alterações na tag head. A tag div com id="root", serve para controlar a interface com o usuário, sendo o responsavel final para com este fim;
	src (origem) -> é a pasta onde mais trabalharei no desenvolvimento:
		1º O ponto de partida para o desenvolvimento, é o arquivo index.js;
		2º O arquivo App.js é o responsável pelo HTML exibido no navegador (representa a visualização que vemos no navegador);
		3º App.css -> é a estilização do html. Contendo classes no componente do aplicativo (app.js);
		4º App.test.js -> para testes de unidade (contendo um caso de teste simples);
		5º Index.css -> aplica estilos para a tag do corpo (body);
		6º Logotipo SVG -> referenciado no componente do aplicativo;
		7º serviceWorker.js -> preocupado com os serviços da web progressivos; 


aula_4: Components

Um componente representa uma parte da interface do usuário.
Ex: um componente seria para cabeçalho, um para navevação, um para o corpo, um para o rodape e um para o "todo". E esse "todo" seria o 'root(App)' (componente de aplicativo);

Como vantagem, os componentes são reutilizaveis. Ou seja, o mesmo componente pode ser usado com propriedades diferentes para exibir informações diferentes.

Como o componente traduz o código em nosso aplicativo?
	O componente geralmente é colocado em um arquivo JS. Por exemplo, o componente AppComponent é colocado em um App.js

Existem dois tipos de componentes: 
	Stateless Functional Componente (Componente Funcional Sem Estado):
		Apresenta funções JavaScript que retornam HTML;
		Ex:	function Welcome (props) {
			   return <h1>Hello, {props.name}</h1>;
			}
	Stateful Class Component (Componente De Classes Com Estado): 
		Trabalha com classe de componente com extensão de classe;
		Devem conter um método de renderização, que por sua vez, retornam HTML;
		Ex:	class Welcome extends React.Component {
			   render() {
			      return <h1>Hello, {this.props.name}</h1>;
			   }
			}


aula_5: Functional Components (presente no arquivo Greet.js)

Os componentes funcionais são apenas funções JavaScript que podem receber propriedades/atributos chamados de "props" e retronar HTML que descreve a interface do usuário.

Criando componentes funcionais:
	1º retiro todo meu HTML da pasta App.js, com excessão da div className="App";
	2º crio uma pasta de nome "components" dentro do meu "src";
	3º Neste arquivo, importo o React;
	4º Crio uma função "Greet", retornando um "Hello Vishwas";

Feito isso, precisarei conecta-lo ao resto do aplicativo.
Para isso, preciso exportar a função greeet e importa-la em App.js. E em seguida, inclui-la no componente do aplicativo;
Em seguida, especificamos o componente com um HTML personalizado com um tag do prórprio nome. E se não houber conteúdo entre as tags, posso usar fechamento automatico;

Porém, uma convenção de boa prática, é usar uma função de "seta" para defini-las. Tornando a abordagem mais concisa que a anterior.
	Ex: const Greet = () => <h1>Hello Vishwas</h1>
Obs: Esta abordagem possui vantagens adcionais;

Diferença entre exportações:
	Exportação padrão: 
		export default Greet;
		Exportação ao final do código.
		Obs: Neste, eu não preciso importat o arquivo com o msm nome. Só a direção (from) já é o suficiente. Ex: import MyGreet from './component/Greet';
	Exportação nomeada:
		export const Greet = () => <h1>Hello Vishwans</h1>;
		Exportação na linha da função.
		Obs: Se faz necessária a importação idêntica ao nome do componente e entre chaves. Ex: import {Greet} from './component/Greet';

Obs: DEVO USAR A ABORDAGEM DE COMPONENTE FUNCIONAL SEMPRE QUE POSSÍVEL;


aula_6: Class Components (presente no arquivo Welcome.js)

São formadas por ES6;
Podem opcionalmente receber (props) como entrada e retornar HTML;
Além dos props, um componente de classe pode manter um estado ("state") interno privado, ou seja, pode conter informações privadas e usa-las pra descrever a interface do usuário;

Sempre em que eu criar um componente de classe, devo incluir duas importações, o React + a classe de componentes:
	import React, { Component } from 'react'

Para uma classe se tornar um component de React, existem duas etapas:
	1º Extender a classse de componente do React:
		Ex: ...extends Component {

		    }
	2º Implementar um método de renderização que retornará nulo ou algum método;
		Ex: class Welcome extends Component {
		       render() {
		       	  return <h1>Class Component</h1>
		       }
 		    }


aula_7: Hooks Update

Os ganchos permitem usar diferentes recursos do React em seus componentes.
Você pode usar os ganchos embutidos ou combiná-los para construir o seu próprio.


aula_8: JSX

JavaScript XML (JSX) - é uma extensão para a sintaxe da linguagem JS.
A biblioteca React é uma extensão para escrever XML como código para elementos e comoponentes.
As tags JSX tem atrubutos de nome, de tag e de filhos.
JSX não é uma necessidade para escrever aplicativos React, porem o torna mais simples e elegante.
JSX se traduz em JS puro que é entendido pelos navegadores.

Diferença de um componente com JSX vs sem JSX:
	Com JSX:
		const Hello = () => {
		   return (
		      <div>
			<h1>Hello World</h1>
		      </div>
		   )
		}
	Sem JSX:
		Para fazer isso, a biblioteca React fornece um método de criação de elemento, veja abaixo.
		const Hello = () => {
		   return React.createElement(
			'div', 							
			{id: hello}, 
			React.create.Element('h1', null, 'Hello Vishwas')
			)
		}	
		A diferenca é que o código agr muda para retornar React.createElement(), aceitando no mínimo três parametros:
			O primeiro parâmetro é a string que especifica a tag HTML a ser renderizada pelo nosso exemplo;
			O segundo, é para propriedade adcional. Quando não há, o resultado é "null";
			O terceiro são os filhos (que podem ser mais de um, inclusive, mais tres parametros);

		O segundo parâmetro basicamente é um objeto de pares chave-valor que serão aplicados ao elemento. Ex: id="hello"; 


aula_9: Props

O React nos permite duplicar um componente quantas vezes desejarmos, porém, tal caracteristica nao é tao usual se nao me permitir alterar alguns detalhes.
Por esse motivo, usa-se o "props" (atributo);


aula_10: State

Assim como o props, ele tambem é capaz de influenciar o que é renderizado na tela.

Props vs State:
	Props:
		- São passadas para o componente;
		- Parametros de função;
		- São imutáveis;
		- Em componentes funcionais -> props;
		- Em componentes de classes -> this.props;

	State:
		- É gerenciado com o componente:
		- Variabeis declaradas no corpo da função;
		- O estado pode ser alterado;
		- Em componentes funcionais -> useState Hook;
		- Em componentes de classe -> this.state;

No state, se faz necesário a criação de um objeto de estado, inicializa-lo. Geralmente é feita dentro da classe constructor().
E dentro dele, chamamos o método super().
Em seguida, criamos nosso objeto de estado -> this.state = {}.
Dentro de nosso objeto, inicializo uma propriedade e crio um valor de estado para ela;
	Ex: constructor() {
		super();
		this.state = {
		   message: 'Wellcome visitor'
		}
	    }

O método setState = ({}) serve para alterar o estado já criado;	


aula_11: setState (presente no arquivo Counte.js)

Sempre faça uso do setState e nuna modifique o estado diretamente.
Se o código tiver que ser executado após o estado ter sido atualizado, coloque esse código na função de retorno de chamada que é o segundo argumanto para o referido metodo de estado.
Quando você tiver que atualizar o estado com base no valor do estado anterior, passe uma função como um argumento em vez do objeto regular.
 Uma melhor explicação a cerca dessa aula, se encontra no vídeo: https://www.youtube.com/watch?v=lURUBUu7IwY


aula_12: Desestruturing props and state

A desestruturaçao é um recurso es6 que torna possível descompactar arrays ou propriedades de objetos em variáveis distintas.
Em React, props de desestruturação e estado melhoram a legibilidade do código. Podendo ser feita tanto no componente funcional, quanto no componente de classe.
	
	Componentes Funcionais (existem duas maneras):
		1ª) É estrutura-lo no próprio parâmetro da função, então, ao invés de apenas inserir (props), teremos parenteses e dentro deles, chaves, para inserirmos as variáveis separadas por vírgula no lugar de props;
			Ex: const Greet = ({name, heroName}) => {
    				return (
        			   <div>
            			      <h1>Hello {name} a.k.a {heroName}</h1>
        			   </div>
    				) 
			     }
		2ª Nesse, voltamos a nomear o parametro como props. E no corpo, adiciono uma const e entre chaves, os atributos igual (=) a props:
			Ex: const Greet = props = {
				const {name, heroName} = props
				return (
        			   <div>
            			      <h1>Hello {name} a.k.a {heroName}</h1>
        			   </div>
    				) 
			     }
	Componentes de Classe (usa-se a segunda maneira):
		Além de funcionar na segunda maneira, posso usar a propriedade de desestruturação de state, seguindo a mesma lógica:
			Ex: class Welcome extends Component {
				render() {
				   const {name, heroName} = this.props
				   // const {state1, state2} = this.state
				   return (
				      <h1>
					Welcome {name} a.k.a {heroName}
				      </h1> 
				   )
				}
			     }


aula_13: Event Handling (Tratamento de Eventos)

Será aprendido com lidar com eventos (click, por exemplo) no React.
Obs: Os eventos de React são nomeado usando letras maiúsculas em vez de minúsculas. Ex: <FunctionClick.js /> (este, localizado no App.js);

	Nos Componentes Funcionais:
		Ex: function  FunctionClick() {
			   
			   function clickHandle() {
				console.log(Button Clicked)
			   }
			   
			   return(
			      <div>
			         <button onClick={clickHandle}>Click</button>
			      </div> 
				)
			}
		Assim como feito em "Counter.js", por conta do JSX, você passa a função como manipulador de eventos, e não como uma simples string,
			então, em vez do manipulador de cliques "clickHandle()" ser entre aspas, teremos o manipulador de cliques entre chaves.
		Nota-se que na clicagem do botão, não adiciono os parenteses, pois não quero que seja uma chamada de função. Queremos que o manipulador seja uma função, e não uma chamada de função.
			Caso contrário, o manipulador ficará chamando o resultado antes mesmo da clicagem do botão.
	
	Nos Componentes de Classe:
		É parecido com os Componentes Funcionais. A única diferença são propriedades já conhecidas:
		Ex: class ClassClick extends React.Component {
				clickHandle() {
					console.log("Clicked the button")
				}
				
				render() {
					return(
						<div>
							<button onclick={this.clickHandle}>Click me</button>
						</div>
					)
				}
			}


aula_14: Binding Event Handlers (Manipuladores de Eventos em Vinculação)

Aprenderemos a como vincular manipuladores de eventos em componentes de React.
O motivo pelo qual vinculamos manipuladores de eventos em React, é puramente por causa da maneira como essa palavra-chave(this) funciona em JavaScript, e não por causa da maneira como o React funciona.
	Ex do que não fazer: class EventBind extends Component {
    
							constructor() {
								super()
								this.state = {
									message: 'Hello'
								}
							}

							clickHandler() {
								this.setState({
									message: 'Goodbye!'
								})
							}
							
							render() {
								return (
									<div>
										<div>{this.state.message}</div>
										<button onClick={this.clickHandler}>Click</button>
									</div>
								)
							}
						}

	Após a criação do botão, criamos uma propriedade de estado chamada message e a vinculamos à interface do usuário;
	Após isso, adicionaremos um atributo "onClick" e sua respectiva função no botão;
	Ao tentar rodar o código desta maneira, perceberei que aparecerá a seguinte mensagem:
			ERROR: Não é possível ler o estado do conjunto de propriedades indefinido; 		
	Então, se eu colocar minha palavra-chave (de um componente de classe), no caso, a palavra "this" em um console.log(), no lugar do atributo "this.setState", será mostrado no console do navegador, a palavra indefined. Indicando um não reconhecimento da mesma: 
		Ex: clickHandler() {
				/*this.setState({
					message: 'Goodbye!'
				})*/
				console.log(this)					
			}
		Obs: Este é um comportamento típico do JS

IMPORTANTE: Lembre-se de que a palavra-chave é indefinida em um manipulador de eventos. E é essa razão pela qual a ligação de evento é necesária em Componentes de Classe React;

Existem várias formas de vinculação de eventos. E nesta aula, todos eles serão examinados!
	Eis a baixo, todas as opções:
		1ª) Temos que usar a palavra-chave bind, que significa "ligação", e vincular o manipulador no método render(). (NÃO ACONSELHAVEL em projetos garndes)
				Ex:	render() {
						return (
							<div>
								<div>{this.state.message}</div>
								<button onClick={this.clickHandler.bind(this)}>Click</button>
							</div>
						)
					}
				Embora esta funcionalidade funcione perfeitamente, cada atualização no estado fará com que o componente seja novamente renderizado, isso por sua vez, gerará outro manipulador de eventos em cada redereização.
				Embora o impacto no desempenho não seja grave em aplicativos pequenos. Pode ser problemático entre aplicativos grandes e em componentes que contém componentes filhos aninhados.
		
		2ª)	Usar função de seta no método render(), dentro do onclick:	(MAIS FÁCIL, PORPÉM, NAO ACONSELHAVEL em projetos garndes ou components com filhos)
					É basicamente chamar o manipulador de eventos no corpo da função de seta, dentro do onClick.
					Ex: render() {
							return (
								<div>
									<div>{this.state.message}</div>
									<button onClick={() => this.clickHandler()}>Click</button>
								</div>
							)
						}
					Observe que não precisamos de chaves ou a palavra-chave return para simbolizar o corpo da função de seta. E isto ocorre porque o corpo da função é uma única instrução.
					Porém, semelhante a primeira abordagem, isso também tem implicações de desempenho em alguns cenários.

		3ª) Vinculação no constructor (MAIS ACONSELHAVEL):
				Essa abordagem lida com a ligação do manipulador de eventos no constuctor() em oposição à ligação no método render().
				Então no constructor(), nós adicionamos uma linha em que adicionaremos: this.clickHandler = this.clickHandler.bind(this);
				Ex: constructor() {
						super()
						this.state = {
							message: 'Hello'
						}
						this.clickHandler = this.clickHandler.bind(this)
					}

					clickHandler() {
						this.setState({
								message: 'Goodbye!'
						})
					}
							
					render() {
						return (
							<div>
								<div>{this.state.message}</div>
									<button onClick={this.clickHandler}>Click</button>
							</div>
						)
					}
				Diferentemente das outras abordagens, é que nessa a vinculação só ocorre uma única vez no constructor, isto é melhor, comparado a vinculação no método render().
		
		4ª) Usar uma função de seta como uma propriedade de classe.	(RECURSO AINDA EXPREIMENTAL)
				Basicamente, se trata em mudar a maneira como você define seu método de classe, nesse caso, o 	clickHandler() {
																													this.setState({
																														message: 'Goodbye!'
																													})
																											   	}
				passa a ser igual a uma função de seta, e dentro dela, a mudança de estado:	clickHandler = () => {
																								this.setState({
																									message:'Goodbye!'
																								})
																							}


aula_15: Methods as props

Vimos como componentes pai podem passar props para seus componentes filhos. Nos dados no componente pai quando passado como props está disponível nos componentes filhos.
Agora, e se um componente filho quisesse se comunicar com o componente pai? Bom...isso ainda seria feito com props. Mas desta vez, passamos uma referência a um método como props para o componente filho.
	Ex's apresentados nos arquivos "ParentComponent.js" e "ChildComponent.js":
		1º Criar um componente Pai:
			class ParentComponents extends React.Component {
    
				constructor() {
					super()
					this.state = {
						parentName: 'parent'
					}
					this.greePatent = this.greetParent.bind(this)
				}

				greetParent() {
					alert(`Hello ${this.state.parentName}`) // Este é um recurso do es6/es7 que substitui a concatenação
				}
				
				render() {
					return(
						<div>
							<ChieldComponent />
						</div>
					)
				}
			}
			Dentro do render(), principalmente da <div>, receberá um componente filho.
		
		2º Criar um componente Filho:
			function ChildComponent() {
				return(
					<div>
						<button>Gree Parent</button>
					</div>
				)
			}

O intuito desses códigos é, ao clicarmos no botão no componente filho, desejamos executar o método definido no componente pai.
Basicamente, um componente filho chama um método de componente pai usando props. A única diferença desta vez é que passamos o próprio método como um prop para o componente filho. Veja abaixo:
	 render() {
        return(
            <div>
                <ChildComponent greetHandler={this.greetParent} />
            </div>
        )
    }
Certifique-se de não adicionar os parênteses, estamos passando uma referência ao método pai como prop, chamado de greetHandler, em pt-br, manipulador de suadação.
Agora, podemos obter essa referência em nosso componente filho:
	function ChildComponent(props) {
		return(
			<div>
				<button onClick={props.greetHandler}>Greet Parent</button>
			</div>
		)
	}
	
Resumindo o que foi feito:
	Chamamos com sucesso um método no componente Pai a partir de um botão no componente Filho, ignorando o método prosp para o componente Filho.

Agora, veremos como passar um parâmetro ao chamar um método Pai do componente Filho, e é aqui que uma função de seta na declaração de retorno se torna útil.
A sintaxe da função de seta é a mais simples maneira de passar parâmetros do componente Filho para o componente Pai:  	
	function ChildComponent(props) {
		return(
			<div>
				<button onClick={() => props.greetHandler()}>Greet Parent</button>
			</div>
		)
	}
Agora, podemos passar um parâmetro, no caso, uma string, do Filho pra o pai:
	function ChildComponent(props) {
		return(
			<div>
				<button onClick={() => props.greetHandler("child")}>Greet Parent</button>
			</div>
		)
	}
E por fim, no método presente no elemento pai, passaremos esse parametro para ele:
	greetParent(childName) {
        alert(`Hello ${this.state.parentName} from ${childName}`)
    }
	
